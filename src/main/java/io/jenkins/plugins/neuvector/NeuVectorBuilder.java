package io.jenkins.plugins.neuvector;

import com.google.common.base.Strings;
import hudson.AbortException;
import hudson.EnvVars;
import hudson.Extension;
import hudson.FilePath;
import hudson.Launcher;
import hudson.model.AbstractProject;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.tasks.ArtifactArchiver;
import hudson.tasks.Builder;
import hudson.tasks.BuildStepDescriptor;
import hudson.util.FormValidation;
import hudson.util.ListBoxModel;
import hudson.util.Secret;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.charset.StandardCharsets;
import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.util.List;
import java.util.Set;

import jenkins.model.Jenkins;
import jenkins.tasks.SimpleBuildStep;
import net.sf.json.JSONArray;
import net.sf.json.JSONException;
import net.sf.json.JSONObject;
import org.jenkinsci.Symbol;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.DataBoundSetter;
import org.kohsuke.stapler.StaplerRequest;
import org.kohsuke.stapler.verb.POST;
import org.kohsuke.stapler.QueryParameter;

import javax.annotation.Nonnull;
import io.jenkins.plugins.neuvector.model.ScanMeta;
import io.jenkins.plugins.neuvector.utils.DockerRegistryClient;


public class NeuVectorBuilder extends Builder implements SimpleBuildStep {

    private static final String REGISTRY_DROPDOWN_DEFAULT = "Please select a registry:";
    private boolean standaloneScanner;
    private final String repository;
    private String tag;
    private boolean scanLayers;
    private String numberOfHighSeverityToFail;
    private String numberOfMediumSeverityToFail;
    private String nameOfVulnerabilityToFailOne;
    private String nameOfVulnerabilityToFailTwo;
    private String nameOfVulnerabilityToFailThree;
    private String nameOfVulnerabilityToFailFour;
    private String nameOfVulnerabilityToExemptOne;
    private String nameOfVulnerabilityToExemptTwo;
    private String nameOfVulnerabilityToExemptThree;
    private String nameOfVulnerabilityToExemptFour;
    private Integer scanTimeout;
    private final String registrySelection;
    private static int buildStep;
    private static int buildHash = 0;
    private Log logger;

    public synchronized static void setBuildStep(int buildStep) {
        NeuVectorBuilder.buildStep = buildStep;
    }

    public synchronized static void setBuildHash(int buildHash) {
        NeuVectorBuilder.buildHash = buildHash;
    }

    @DataBoundConstructor
    public NeuVectorBuilder(String repository, String registrySelection) {
        this.repository = repository;
        this.registrySelection = registrySelection;
    }

    public boolean getStandaloneScanner() {return standaloneScanner;}

    public String getRepository() {
        return repository;
    }

    public String getTag() {
        return tag;
    }

    public boolean getScanLayers() {
        return scanLayers;
    }

    public Integer getScanTimeout() { return scanTimeout; }

    public String getNumberOfHighSeverityToFail() {
        return numberOfHighSeverityToFail;
    }

    public String getNumberOfMediumSeverityToFail() {
        return numberOfMediumSeverityToFail;
    }

    public String getNameOfVulnerabilityToFailOne() {
        return nameOfVulnerabilityToFailOne;
    }

    public String getNameOfVulnerabilityToFailTwo() {
        return nameOfVulnerabilityToFailTwo;
    }

    public String getNameOfVulnerabilityToFailThree() {
        return nameOfVulnerabilityToFailThree;
    }

    public String getNameOfVulnerabilityToFailFour() {
        return nameOfVulnerabilityToFailFour;
    }

    public String getNameOfVulnerabilityToExemptOne() {
        return nameOfVulnerabilityToExemptOne;
    }

    public String getNameOfVulnerabilityToExemptTwo() {
        return nameOfVulnerabilityToExemptTwo;
    }

    public String getNameOfVulnerabilityToExemptThree() {
        return nameOfVulnerabilityToExemptThree;
    }

    public String getNameOfVulnerabilityToExemptFour() {
        return nameOfVulnerabilityToExemptFour;
    }

    public String getRegistrySelection() {
        return registrySelection;
    }

    @DataBoundSetter
    public void setStandaloneScanner(boolean standaloneScanner) { this.standaloneScanner = standaloneScanner; }

    @DataBoundSetter
    public void setTag(String tag) {
        this.tag = tag.trim();
    }

    @DataBoundSetter
    public void setScanLayers(boolean scanLayers) {
        this.scanLayers = scanLayers;
    }

    @DataBoundSetter
    public void setScanTimeout(int scanTimeout) { this.scanTimeout = scanTimeout; }

    @DataBoundSetter
    public void setNumberOfHighSeverityToFail(String numberOfHighSeverityToFail) {
        this.numberOfHighSeverityToFail = numberOfHighSeverityToFail.trim();
    }

    @DataBoundSetter
    public void setNumberOfMediumSeverityToFail(String numberOfMediumSeverityToFail) {
        this.numberOfMediumSeverityToFail = numberOfMediumSeverityToFail.trim();
    }

    @DataBoundSetter
    public void setNameOfVulnerabilityToFailOne(String nameOfVulnerabilityToFailOne) {
        this.nameOfVulnerabilityToFailOne = nameOfVulnerabilityToFailOne.trim();
    }

    @DataBoundSetter
    public void setNameOfVulnerabilityToFailTwo(String nameOfVulnerabilityToFailTwo) {
        this.nameOfVulnerabilityToFailTwo = nameOfVulnerabilityToFailTwo.trim();
    }

    @DataBoundSetter
    public void setNameOfVulnerabilityToFailThree(String nameOfVulnerabilityToFailThree) {
        this.nameOfVulnerabilityToFailThree = nameOfVulnerabilityToFailThree.trim();
    }

    @DataBoundSetter
    public void setNameOfVulnerabilityToFailFour(String nameOfVulnerabilityToFailFour) {
        this.nameOfVulnerabilityToFailFour = nameOfVulnerabilityToFailFour.trim();
    }

    @DataBoundSetter
    public void setNameOfVulnerabilityToExemptOne(String nameOfVulnerabilityToExemptOne) {
        this.nameOfVulnerabilityToExemptOne = nameOfVulnerabilityToExemptOne.trim();
    }

    @DataBoundSetter
    public void setNameOfVulnerabilityToExemptTwo(String nameOfVulnerabilityToExemptTwo) {
        this.nameOfVulnerabilityToExemptTwo = nameOfVulnerabilityToExemptTwo.trim();
    }

    @DataBoundSetter
    public void setNameOfVulnerabilityToExemptThree(String nameOfVulnerabilityToExemptThree) {
        this.nameOfVulnerabilityToExemptThree = nameOfVulnerabilityToExemptThree.trim();
    }

    @DataBoundSetter
    public void setNameOfVulnerabilityToExemptFour(String nameOfVulnerabilityToExemptFour) {
        this.nameOfVulnerabilityToExemptFour = nameOfVulnerabilityToExemptFour.trim();
    }

    @Override
    public void perform(@Nonnull Run<?, ?> run, @Nonnull FilePath workspace, @Nonnull Launcher launcher, @Nonnull TaskListener listener)
            throws IOException, InterruptedException {

        // init the logger
        this.logger = new Log(listener.getLogger());

        // copy styles.css to workspace
        File cssFile;
        final EnvVars env = run.getEnvironment(listener);
        FilePath targetCss = new FilePath(workspace, "styles.css");

        cssFile = new File(env.get("JENKINS_HOME") + "/plugins/neuvector-vulnerability-scanner/css/", "styles.css");
        FilePath cssFilePath = new FilePath(cssFile);
        cssFilePath.copyTo(targetCss);

        String artifactName = "NeuVectorReport_" + run.getParent().getDisplayName() + "_" + run.getNumber();
        String reportNumber;
        //get the build step number as the part of the artifact name
        if (run.hashCode() != buildHash) {
            setBuildHash(run.hashCode());
            setBuildStep(1);
        } else {
            setBuildStep(buildStep + 1);
        }
        reportNumber = Integer.toString(buildStep);
        artifactName = artifactName + "-" + reportNumber ;

        //to init config with scan parameters
        Config config = null;
        try {
            config = printInfoFromUser(run, listener);
        } catch (URISyntaxException e) {
            e.printStackTrace();
        }

        //to create a worker object to run the scan
        NeuVectorWorker worker = new NeuVectorWorker(logger, config, workspace, artifactName);
        try{
            worker.scan(run, launcher);
        }catch (Exception ex) {
            archiveAndAddAction(run, workspace, launcher, listener, artifactName, reportNumber);
            throw new AbortException(ex.getMessage());
        }

        archiveAndAddAction(run, workspace, launcher, listener, artifactName, reportNumber);

    }

    private String getBuildUser(String url) throws IOException{
        StringBuilder result = new StringBuilder();
        URL urlVar = new URL(url);
        HttpURLConnection conn = (HttpURLConnection) urlVar.openConnection();
        conn.setRequestMethod("GET");
        try(BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream(), StandardCharsets.UTF_8))){
            String line;
            while ((line = rd.readLine()) != null) {
                result.append(line);
            }
        }

        String userName = "";
        try{
            JSONObject json = JSONObject.fromObject(result.toString());
            JSONObject action = (JSONObject) json.getJSONArray("actions").get(0);
            JSONObject cause = (JSONObject) action.getJSONArray("causes").get(0);
            userName = cause.getString("userName");
        }catch(JSONException e){
            userName = "anonymous";
        }

        return userName;
    }

    public static String getLastElementInRepoString(String input) {
        String[] parts = input.split("/");
        return parts[parts.length - 1];
    }

    private Config printInfoFromUser(Run<?, ?> run, TaskListener listener) throws AbortException, URISyntaxException {
        DescriptorImpl globalConfig = getDescriptor();
        String controllerApiUrl ="";
        if (globalConfig.getControllerApiUrl() != null){
            controllerApiUrl = globalConfig.getControllerApiUrl().trim();
        };

        String user = "";
        if (globalConfig.getUser() != null) {
            user = globalConfig.getUser().trim();
        }

        String password = "";
        if (globalConfig.getPassword() != null) {
            password = Secret.toString(globalConfig.getPassword()).trim();
        }

        boolean disableTLSCertVerification = globalConfig.getDisableTLSCertVerification();
        String serverCertificate = globalConfig.getServerCertificate();
        int timeout = globalConfig.getTimeout();
        List<Registry> registries = globalConfig.getRegistries(); //registries can be null if nothing in global config

        if (repository == null || registrySelection == null) {
            throw new AbortException("repository and registrySelection both are required.");
        }

        final EnvVars env;
        try {
            env = run.getEnvironment(listener);
        } catch (IOException | InterruptedException e) {
            throw new AbortException("Error when getting Jenkins project environment.");
        }
        String currentRepository = env.expand(repository.trim());
        String currentTag = env.expand(tag);

        String buildUrl = env.get("BUILD_URL")+"api/json";
        String buildUser = "";
        try {
            buildUser = getBuildUser(buildUrl);
        } catch (IOException e) {
            logger.println("Build user not found.");
        }

        logger.println("");
        logger.println("*************************************************************");

        ScanMeta scanMeta = new ScanMeta();
        scanMeta.setSource(globalConfig.getSource());
        scanMeta.setUser(buildUser);
        scanMeta.setJob(env.get("JOB_NAME"));
        scanMeta.setWorkspace(env.get("WORKSPACE"));

        if(scanMeta.getSource() == null || scanMeta.getSource().isEmpty()){
            logger.println("Scanner Source Name: (Please set a name in Jenkins -> Configure System -> NeuVector Vulnerablity Scanner -> NeuVector Scanner Source Name )");
        }else{
            logger.println("Scanner Source Name: " + scanMeta.getSource());
        }

        logger.println("Build User: " + scanMeta.getUser());
        logger.println("Job Name: " + scanMeta.getJob());
        logger.println("Workspace: " + scanMeta.getWorkspace());

        boolean isLocal = true;
        Registry selectRegistry = null;

        if (Strings.isNullOrEmpty(registrySelection) || registrySelection.equalsIgnoreCase(REGISTRY_DROPDOWN_DEFAULT)) {
            // Case: no registry selected in task.
            throw new AbortException("Please select a registry or choose Local.");
        } else if (registrySelection.equalsIgnoreCase("Local")) {
            // Case: Local.
            logger.println("Local case.");
        } else {
            // Case: pre-defined registry selected. Maybe deleted already.
            if (registries == null) {
                // Case: registry deleted in global
                throw new AbortException("Registry " + registrySelection + " in current project is missing or deleted in global configuration.");
            } else {
                boolean found = false;
                for (Registry registry : registries) {
                    if (registry.getNickname().isEmpty() || registry.getRegUrl().isEmpty()) {
                        throw new AbortException("Registry nickname and URL cannot be empty");
                    }
                    if (registry.getNickname().equalsIgnoreCase(registrySelection)) {
                        // Case: registry found in global
                        found = true;
                        isLocal = false;
                        selectRegistry = registry;
                        logger.println("Registry: " + registrySelection);
                        logger.println("Registry URL: " + selectRegistry.getRegUrl());
                        logger.println("Registry Username: " + selectRegistry.getRegUsername());
                        break;
                    }
                }
                if (!found) {
                    // Case: registry deleted in global
                    throw new AbortException("Registry " + registrySelection + " in current project is missing or deleted in global configuration.");
                }
            }
        }

        logger.println("Repository: " + currentRepository);
        logger.println("Tag: " + currentTag);

        Double highSeverityThreshold = globalConfig.highSeverityThreshold;
        Double mediumSeverityThreshold = globalConfig.mediumSeverityThreshold;
        boolean customizedRatingScale = false;
        if(highSeverityThreshold != null && mediumSeverityThreshold != null) {
            customizedRatingScale = true;
        }
        
        /*
        * currentRepository will be formulated to "{username}/{repository}".
        * If the username is empty, consider it a public registry and add "library/" prefix.
        * If the input already contains a "/", we consider it already formulated.
        */
        if (!globalConfig.scannerRegistryUser.isEmpty()) {
            String repoStr = getLastElementInRepoString(currentRepository);
            DockerRegistryClient dockerRegistryClient = new DockerRegistryClient(
                globalConfig.scannerRegistryUser,
                globalConfig.scannerRegistryPassword.getPlainText()
            );
        
            try {
                Set<String> repoWithTags = dockerRegistryClient.getAllRepositoriesWithTagsAll();
                String scanRepoWithTag = repoStr + ":" + tag;
                if (repoWithTags.contains(scanRepoWithTag)) {
                    currentRepository = globalConfig.scannerRegistryUser + "/" + repoStr;
                } else {
                    currentRepository = "library/" + repoStr;
                }
            } catch (Exception e) {
                logger.println("Error retrieving repositories and tags: " + e.getMessage());
            }
        } else {
            if (!currentRepository.contains("/")) {
                currentRepository = "library/" + currentRepository;
            }
        }
        return new Config.ConfigBuilder(controllerApiUrl, user, password, disableTLSCertVerification, serverCertificate)
                .standaloneScanner(standaloneScanner)
                .scanMeta(scanMeta)
                .timeout(timeout)
                .isLocal(isLocal)
                .scannerRegistryURL(globalConfig.scannerRegistryURL)
                .scannerRegistryUser(globalConfig.scannerRegistryUser)
                .scannerRegistryPassword(globalConfig.scannerRegistryPassword)
                .scannerImage(globalConfig.scannerImage)
                .registry(selectRegistry)
                .repository(currentRepository)
                .tag(currentTag)
                .scanLayers(scanLayers)
                .scanTimeout(scanTimeout)
                .highSeverityThreshold(highSeverityThreshold)
                .mediumSeverityThreshold(mediumSeverityThreshold)
                .customizedRatingScale(customizedRatingScale)
                .numberOfHighSeverityToFail(numberOfHighSeverityToFail)
                .numberOfMediumSeverityToFail(numberOfMediumSeverityToFail)
                .nameOfVulnerabilityToFailOne(nameOfVulnerabilityToFailOne)
                .nameOfVulnerabilityToFailTwo(nameOfVulnerabilityToFailTwo)
                .nameOfVulnerabilityToFailThree(nameOfVulnerabilityToFailThree)
                .nameOfVulnerabilityToFailFour(nameOfVulnerabilityToFailFour)
                .nameOfVulnerabilityToExemptOne(nameOfVulnerabilityToExemptOne)
                .nameOfVulnerabilityToExemptTwo(nameOfVulnerabilityToExemptTwo)
                .nameOfVulnerabilityToExemptThree(nameOfVulnerabilityToExemptThree)
                .nameOfVulnerabilityToExemptFour(nameOfVulnerabilityToExemptFour)
                .build();
    }

    private void archiveAndAddAction(Run<?, ?> run, FilePath workspace, Launcher launcher, TaskListener listener, String artifactName, String reportNumber){

        try {
            ArtifactArchiver artifactArchiver = new ArtifactArchiver(artifactName);
            artifactArchiver.perform(run, workspace, launcher, listener);
        } catch (Exception e) {
            logger.println("Failed to archive the artifact file: " + artifactName);
        }

        String artifactNameHTML = artifactName + ".html";
        try {
            ArtifactArchiver artifactArchiver = new ArtifactArchiver(artifactNameHTML);
            artifactArchiver.perform(run, workspace, launcher, listener);
        } catch (Exception e) {
            logger.println("Failed to archive the artifact HTML: " + artifactNameHTML);
        }

        String artifactNameJson = artifactName + ".json";
        try {
            ArtifactArchiver artifactArchiver = new ArtifactArchiver(artifactNameJson);
            artifactArchiver.perform(run, workspace, launcher, listener);
        } catch (Exception e) {
            logger.println("Failed to archive the artifact Json: " + artifactNameJson);
        }

        try {
            ArtifactArchiver artifactArchiver = new ArtifactArchiver("styles.css");
            artifactArchiver.perform(run, workspace, launcher, listener);
        } catch (Exception e) {
            logger.println("Failed to archive the artifact css style file. ");
        }

        run.addAction(new NeuVectorAction(run, artifactNameHTML, reportNumber));
    }

    @Override
    public DescriptorImpl getDescriptor() {
        return (DescriptorImpl) super.getDescriptor();
    }

    @Symbol("neuvector")
    @Extension
    public static final class DescriptorImpl extends BuildStepDescriptor<Builder> {
        /**
         * To persist global configuration information, simply store it in a field and
         * call save().
         */
        private String source;
        private String controllerIP;
        private String controllerPort;
        private String controllerApiUrl;
        private String user;
        private Secret password;
        private int timeout;
        private String scannerRegistryURL;
        private String scannerImage;
        private boolean disableTLSCertVerification;
        private String serverCertificate;
        private String scannerRegistryUser;
        private Secret scannerRegistryPassword;
        private Double mediumSeverityThreshold;
        private Double highSeverityThreshold;
        private List<Registry> registries;

        public void setSource(String source) { this.source = source; }
        public void setScannerRegistryURL(String scannerRegistryURL) {
            this.scannerRegistryURL = scannerRegistryURL;
        }

        public void setScannerImage(String scannerImage) {
            this.scannerImage = scannerImage;
        }
        public void setDisableTLSCertVerification(Boolean disableTLSCertVerification) {this.disableTLSCertVerification = disableTLSCertVerification;}
        public void setServerCertificate(String serverCertificate) {this.serverCertificate = serverCertificate;}

        public void setScannerRegistryUser(String scannerRegistryUser) {
            this.scannerRegistryUser = scannerRegistryUser;
        }

        public void setScannerRegistryPassword(Secret scannerRegistryPassword) {
            this.scannerRegistryPassword = scannerRegistryPassword;
        }

        public void setControllerIP(String controllerIP) {
            this.controllerIP = controllerIP;
        }

        public void setControllerPort(String controllerPort) {
            this.controllerPort = controllerPort;
        }

        public void setControllerApiUrl(String controllerApiUrl) {
            this.controllerApiUrl = controllerApiUrl;
        }

        public void setUser(String user) {
            this.user = user;
        }

        public void setPassword(Secret password) {
            this.password = password;
        }

        public void setTimeout(int timeout) {
            this.timeout = timeout;
        }

        public void setRegistries(List<Registry> registries) {
            this.registries = registries;
        }

        public void setMediumSeverityThreshold(Double mediumSeverityThreshold) {
            this.mediumSeverityThreshold = mediumSeverityThreshold;
        }

        public void setHighSeverityThreshold(Double highSeverityThreshold) {
            this.highSeverityThreshold = highSeverityThreshold;
        }

        public Double getMediumSeverityThreshold() {
            return mediumSeverityThreshold;
        }

        public Double getHighSeverityThreshold() {
            return highSeverityThreshold;
        }

        public String getSource() {
            return source;
        }

        public String getControllerApiUrl() {
            return controllerApiUrl;
        }

        public String getUser() {
            return user;
        }

        public Secret getPassword() {
            return password;
        }

        public int getTimeout() {
            return timeout;
        }

        public String getScannerRegistryURL() {
            return scannerRegistryURL;
        }

        public String getScannerImage() {
            return scannerImage;
        }

        public Boolean getDisableTLSCertVerification() {
            return disableTLSCertVerification;
        }

        public String getServerCertificate() {
            return serverCertificate;
        }

        public String getScannerRegistryUser() {
            return scannerRegistryUser;
        }

        public Secret getScannerRegistryPassword() {
            return scannerRegistryPassword;
        }

        public List<Registry> getRegistries() {
            return registries;
        }

        public DescriptorImpl() {
            load();
        }

        public ListBoxModel doFillRegistrySelectionItems() {
            ListBoxModel items = new ListBoxModel();
            items.add(REGISTRY_DROPDOWN_DEFAULT);
            items.add("Local");
            if (registries != null) {
                for (Registry reg : registries) {
                    items.add(reg.getNickname());
                }
            }
            return items;
        }

        public FormValidation doCheckScanTimeout(@QueryParameter("scanTimeout") Integer scanTimeout){
            if(scanTimeout > 0 && scanTimeout <=60){
                return FormValidation.ok();
            }
            return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_scanTimeout());
        }
        public FormValidation doCheckRegistrySelection(@QueryParameter String value) {
            if (Strings.isNullOrEmpty(value) || value.equalsIgnoreCase(REGISTRY_DROPDOWN_DEFAULT)) {
                return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_registrySelection());
            }
            return FormValidation.ok();
        }

        public FormValidation doCheckControllerApiUrl(@QueryParameter String value) {
            if (value != null && !value.trim().isEmpty() && ! value.trim().matches("^https://([a-zA-Z0-9.-]+)(:([0-9]+))?(/[a-zA-Z0-9./-]+)?$")) {
                return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_controllerApiUrl());
            }
            return FormValidation.ok();
        }

        public FormValidation doCheckTimeout(@QueryParameter String value) {
            try {
                if (Integer.parseInt(value) < 0) {
                    return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_timeout());
                }
                return FormValidation.ok();
            } catch (NumberFormatException e) {
                return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_timeout());
            }
        }

        public FormValidation doCheckMediumSeverityThreshold(@QueryParameter Double value, @QueryParameter Double highSeverityThreshold) {
            if( value != null){
                if(value < 0.0 || value > 10.0){
                    return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_invalidScore());
                }else if( highSeverityThreshold == null ){
                    return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_missingSeverityScore());
                }
            }

            return FormValidation.ok();
        }

        public FormValidation doCheckHighSeverityThreshold(@QueryParameter Double value, @QueryParameter Double mediumSeverityThreshold) {
            if( value != null){
                if(value < 0.0 || value > 10.0){
                    return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_invalidScore());
                }else if( mediumSeverityThreshold == null ){
                    return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_missingSeverityScore());
                }else if( value <= mediumSeverityThreshold){
                    return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_invalidThreshold());
                }
            }

            return FormValidation.ok();
        }

        @POST
        public FormValidation doTestConnection(@QueryParameter("controllerApiUrl") String controllerApiUrl,
                                               @QueryParameter("user") String user,
                                               @QueryParameter("password") Secret password,
                                               @QueryParameter("disableTLSCertVerification") boolean disableTLSCertVerification,
                                               @QueryParameter("serverCertificate") String serverCertificate) throws URISyntaxException {
            Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);
            Config config = new Config.ConfigBuilder(controllerApiUrl, user, Secret.toString(password).trim(),disableTLSCertVerification,serverCertificate).build();
            NeuVectorWorker worker = new NeuVectorWorker(null, config);
            try {
                worker.testConnection();
                return FormValidation.ok("Connection Success");
            } catch (Exception e) {
                return FormValidation.error("Failed to connect " + config.getControllerApiUrl().toString() + ". " + e.getMessage());
            }
        }

        @Override
        public boolean isApplicable(Class<? extends AbstractProject> aClass) {
            return true;
        }

        @Override
        public String getDisplayName() {
            return Messages.NeuVectorBuilder_DescriptorImpl_DisplayName();
        }

        @Override
        public boolean configure(StaplerRequest req, JSONObject formData) {
            try {
                JSONObject registriesJsonObj = formData.getJSONObject("registries");
                if (registriesJsonObj == null || registriesJsonObj.isEmpty()) {
                    registries = null;
                }
            } catch (JSONException e) {
                JSONArray registriesJsonArray = formData.getJSONArray("registries");
                if (registriesJsonArray == null || registriesJsonArray.isEmpty()) {
                    registries = null;
                }
            }
            req.bindJSON(this, formData);
            save();
            return true;
        }
        
        protected Object readResolve() {
            /*
            * TLS certificate verification is enabled by default, but it will be disabled in the following scenario:
            * 
            * To ensure compatibility with users who are upgrading from non-TLS verification version, 
            * we check if the user has previously used API mode when upgrading from non-TLS verification version. 
            * 
            * To check if this is a migrated from non-TLS verification version, we can check serverCertificate is null,
            * since we add serverCertificate when we have TLS verification.
            * 
            * If they have not used Controller & Scanner mode before,
            * verification will remain enabled; otherwise, it will be disabled.
            */

            boolean migrated = (serverCertificate == null);
            
            if (migrated) {
                disableTLSCertVerification = (user != null && !user.isEmpty());
            }

            /*
            * This code handles the scenario where users are upgrading from an older version of the plugin,
            * which used controllerIP and port for the scanner API URL. It ensures that the controller IP
            * and port settings are automatically migrated to the new input field "controllerAPIUrl"
            *
            */
            if(controllerApiUrl == null || controllerApiUrl.isEmpty()){
                if(controllerIP != null && !controllerIP.isEmpty() && controllerPort != null && !controllerPort.isEmpty()) {
                    controllerApiUrl = "https://" + controllerIP.trim() + ":" + controllerPort.trim();
                }
            }
            return this;
          }
    }
}
