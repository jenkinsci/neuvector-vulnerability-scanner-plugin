package io.jenkins.plugins.neuvector;

import com.google.common.base.Strings;
import hudson.AbortException;
import hudson.EnvVars;
import hudson.Extension;
import hudson.FilePath;
import hudson.Launcher;
import hudson.model.AbstractProject;
import hudson.model.Run;
import hudson.model.TaskListener;
import hudson.tasks.ArtifactArchiver;
import hudson.tasks.Builder;
import hudson.tasks.BuildStepDescriptor;
import hudson.util.FormValidation;
import hudson.util.ListBoxModel;
import hudson.util.Secret;

import java.io.IOException;
import java.io.PrintStream;
import java.util.List;

import jenkins.tasks.SimpleBuildStep;
import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import net.sf.json.JSONException;
import org.jenkinsci.Symbol;
import org.kohsuke.stapler.DataBoundConstructor;
import org.kohsuke.stapler.DataBoundSetter;
import org.kohsuke.stapler.StaplerRequest;
import org.kohsuke.stapler.QueryParameter;

import javax.annotation.Nonnull;

import static hudson.Util.fixEmpty;

public class NeuVectorBuilder extends Builder implements SimpleBuildStep {

    private static final String REGISTRY_DROPDOWN_DEFAULT = "Please select a registry:";
    private final String repository;
    private String tag;
    private boolean scanLayers;
    private String numberOfHighSeverityToFail;
    private String numberOfMediumSeverityToFail;
    private String nameOfVulnerabilityToFailOne;
    private String nameOfVulnerabilityToFailTwo;
    private String nameOfVulnerabilityToFailThree;
    private String nameOfVulnerabilityToFailFour;
    private final String registrySelection;
    private static int buildStep;
    private static int buildHash = 0;

    public synchronized static void setBuildStep(int buildStep) {
        NeuVectorBuilder.buildStep = buildStep;
    }

    public synchronized static void setBuildHash(int buildHash) {
        NeuVectorBuilder.buildHash = buildHash;
    }

    @DataBoundConstructor
    public NeuVectorBuilder(String repository, String registrySelection) {
        this.repository = repository;
        this.registrySelection = registrySelection;
    }

    public String getRepository() {
        return repository;
    }

    public String getTag() {
        return tag;
    }

    public boolean getScanLayers() {
        return scanLayers;
    }

    public String getNumberOfHighSeverityToFail() {
        return numberOfHighSeverityToFail;
    }

    public String getNumberOfMediumSeverityToFail() {
        return numberOfMediumSeverityToFail;
    }

    public String getNameOfVulnerabilityToFailOne() {
        return nameOfVulnerabilityToFailOne;
    }

    public String getNameOfVulnerabilityToFailTwo() {
        return nameOfVulnerabilityToFailTwo;
    }

    public String getNameOfVulnerabilityToFailThree() {
        return nameOfVulnerabilityToFailThree;
    }

    public String getNameOfVulnerabilityToFailFour() {
        return nameOfVulnerabilityToFailFour;
    }

    public String getRegistrySelection() {
        return registrySelection;
    }

    @DataBoundSetter
    public void setTag(String tag) {
        this.tag = fixEmpty(tag.trim());
    }

    @DataBoundSetter
    public void setScanLayers(boolean scanLayers) {
        this.scanLayers = scanLayers;
    }

    @DataBoundSetter
    public void setNumberOfHighSeverityToFail(String numberOfHighSeverityToFail) {
        this.numberOfHighSeverityToFail = fixEmpty(numberOfHighSeverityToFail.trim());
    }

    @DataBoundSetter
    public void setNumberOfMediumSeverityToFail(String numberOfMediumSeverityToFail) {
        this.numberOfMediumSeverityToFail = fixEmpty(numberOfMediumSeverityToFail.trim());
    }

    @DataBoundSetter
    public void setNameOfVulnerabilityToFailOne(String nameOfVulnerabilityToFailOne) {
        this.nameOfVulnerabilityToFailOne = fixEmpty(nameOfVulnerabilityToFailOne.trim());
    }

    @DataBoundSetter
    public void setNameOfVulnerabilityToFailTwo(String nameOfVulnerabilityToFailTwo) {
        this.nameOfVulnerabilityToFailTwo = fixEmpty(nameOfVulnerabilityToFailTwo.trim());
    }

    @DataBoundSetter
    public void setNameOfVulnerabilityToFailThree(String nameOfVulnerabilityToFailThree) {
        this.nameOfVulnerabilityToFailThree = fixEmpty(nameOfVulnerabilityToFailThree.trim());
    }

    @DataBoundSetter
    public void setNameOfVulnerabilityToFailFour(String nameOfVulnerabilityToFailFour) {
        this.nameOfVulnerabilityToFailFour = fixEmpty(nameOfVulnerabilityToFailFour.trim());
    }

    @Override
    public void perform(@Nonnull Run<?, ?> run, @Nonnull FilePath workspace, @Nonnull Launcher launcher, @Nonnull TaskListener listener)
            throws IOException, InterruptedException {
        String artifactName = "NeuVectorReport_" + run.getParent().getDisplayName() + "_" + run.getNumber();
        String reportNumber = null;
        if (run.hashCode() != buildHash) {
            setBuildHash(run.hashCode());
            setBuildStep(1);
        } else {
            setBuildStep(buildStep + 1);
        }
        reportNumber = Integer.toString(buildStep);
        artifactName = artifactName + "-" + reportNumber;
        FilePath workspaceFP = new FilePath(workspace, artifactName);

        try (PrintStream printStream = new PrintStream(workspaceFP.write(), false, "UTF-8")) {
            Log logger = new Log(printStream, listener);

            Config config = printInfoFromUser(run, listener, logger);

            NeuVectorWorker worker = new NeuVectorWorker(logger, config);
            worker.scan();
        } finally {
            archiveAndAddAction(run, workspace, launcher, listener, artifactName, reportNumber);
            workspaceFP.delete();
        }
    }

    private Config printInfoFromUser(Run<?, ?> run, TaskListener listener, Log logger) throws AbortException {
        DescriptorImpl globalConfig = getDescriptor();
        String controllerIP = globalConfig.getControllerIP().trim();
        int controllerPort = Integer.parseInt(globalConfig.getControllerPort().trim());
        String user = globalConfig.getUser().trim();
        String password = Secret.toString(globalConfig.getPassword()).trim();
        int timeout = globalConfig.getTimeout();
        List<Registry> registries = globalConfig.getRegistries(); //registries can be null if nothing in global config

        if (controllerIP.isEmpty() || user.isEmpty() || password.isEmpty()) {
            throw new AbortException("Missing global configuration for NeuVector.");
        }

        if (repository == null || registrySelection == null) {
            throw new AbortException("repository and registrySelection both are required.");
        }

        final EnvVars env;
        try {
            env = run.getEnvironment(listener);
        } catch (IOException | InterruptedException e) {
            throw new AbortException("Error when getting Jenkins project environment.");
        }
        String currentRepository = env.expand(repository.trim());
        String currentTag = env.expand(tag);

        logger.log();
        logger.log("*************************************************************");

        boolean isLocal = true;
        Registry selectRegistry = null;

        if (Strings.isNullOrEmpty(registrySelection) || registrySelection.equalsIgnoreCase(REGISTRY_DROPDOWN_DEFAULT)) {
            // Case: no registry selected in task.
            throw new AbortException("Please select a registry or choose Local.");
        } else if (registrySelection.equalsIgnoreCase("Local")) {
            // Case: Local.
            logger.log("Local case.");
        } else {
            // Case: pre-defined registry selected. Maybe deleted already.
            if (registries == null) {
                // Case: registry deleted in global
                throw new AbortException("Registry " + registrySelection + " in current project is missing or deleted in global configuration.");
            } else {
                boolean found = false;
                for (Registry registry : registries) {
                    if (registry.getNickname().isEmpty() || registry.getRegUrl().isEmpty()) {
                        throw new AbortException("Registry nickname and URL cannot be empty");
                    }
                    if (registry.getNickname().equalsIgnoreCase(registrySelection)) {
                        // Case: registry found in global
                        found = true;
                        isLocal = false;
                        selectRegistry = registry;
                        logger.log("Registry: " + registrySelection);
                        logger.log("Registry URL: " + selectRegistry.getRegUrl());
                        logger.log("Registry Username: " + selectRegistry.getRegUsername());
                        break;
                    }
                }
                if (!found) {
                    // Case: registry deleted in global
                    throw new AbortException("Registry " + registrySelection + " in current project is missing or deleted in global configuration.");
                }
            }
        }

        logger.log("Repository: " + currentRepository);
        logger.log("Tag: " + currentTag);

        return new Config(controllerIP, controllerPort, user, password, timeout, isLocal, selectRegistry,
                currentRepository, currentTag, scanLayers, numberOfHighSeverityToFail, numberOfMediumSeverityToFail,
                nameOfVulnerabilityToFailOne, nameOfVulnerabilityToFailTwo, nameOfVulnerabilityToFailThree,
                nameOfVulnerabilityToFailFour);
    }

    private void archiveAndAddAction(Run<?, ?> run, FilePath workspace, Launcher launcher, TaskListener listener, String artifactName, String reportNumber)
            throws InterruptedException, IOException {
        ArtifactArchiver artifactArchiver = new ArtifactArchiver(artifactName);
        artifactArchiver.perform(run, workspace, launcher, listener);
        run.addAction(new NeuVectorAction(run, artifactName, reportNumber));
    }

    @Override
    public DescriptorImpl getDescriptor() {
        return (DescriptorImpl) super.getDescriptor();
    }

    @Symbol("neuvector")
    @Extension
    public static final class DescriptorImpl extends BuildStepDescriptor<Builder> {
        /**
         * To persist global configuration information, simply store it in a field and
         * call save().
         */
        private String controllerIP;
        private String controllerPort;
        private String user;
        private Secret password;
        private int timeout;
        private List<Registry> registries;

        public void setControllerIP(String controllerIP) {
            this.controllerIP = controllerIP;
        }

        public void setControllerPort(String controllerPort) {
            this.controllerPort = controllerPort;
        }

        public void setUser(String user) {
            this.user = user;
        }

        public void setPassword(Secret password) {
            this.password = password;
        }

        public void setTimeout(int timeout) {
            this.timeout = timeout;
        }

        public void setRegistries(List<Registry> registries) {
            this.registries = registries;
        }

        public String getControllerIP() {
            return controllerIP;
        }

        public String getControllerPort() {
            return controllerPort;
        }

        public String getUser() {
            return user;
        }

        public Secret getPassword() {
            return password;
        }

        public int getTimeout() {
            return timeout;
        }

        public List<Registry> getRegistries() {
            return registries;
        }

        public DescriptorImpl() {
            load();
        }

        public ListBoxModel doFillRegistrySelectionItems() {
            ListBoxModel items = new ListBoxModel();
            items.add(REGISTRY_DROPDOWN_DEFAULT);
            items.add("Local");
            if (registries != null) {
                for (Registry reg : registries) {
                    items.add(reg.getNickname());
                }
            }
            return items;
        }

        public FormValidation doCheckRegistrySelection(@QueryParameter String value) {
            if (Strings.isNullOrEmpty(value) || value.equalsIgnoreCase(REGISTRY_DROPDOWN_DEFAULT)) {
                return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_registrySelection());
            }
            return FormValidation.ok();
        }

        public FormValidation doCheckControllerIP(@QueryParameter String value) {
            if (Strings.isNullOrEmpty(value) || value.trim().isEmpty() || value.trim().matches("^(http|https)://.*$")) {
                return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_controllerIP());
            }
            return FormValidation.ok();
        }

        public FormValidation doCheckControllerPort(@QueryParameter String value) {
            try {
                if (Integer.parseInt(value.trim()) < 0) {
                    return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_controllerPort());
                }
                return FormValidation.ok();
            } catch (NumberFormatException e) {
                return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_controllerPort());
            }
        }

        public FormValidation doCheckUser(@QueryParameter String value) {
            if (Strings.isNullOrEmpty(value) || value.trim().isEmpty()) {
                return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_user());
            }
            return FormValidation.ok();
        }

        public FormValidation doCheckPassword(@QueryParameter Secret value) {
            if (Secret.toString(value).trim().isEmpty()) {
                return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_password());
            }
            return FormValidation.ok();
        }

        public FormValidation doCheckTimeout(@QueryParameter String value) {
            try {
                if (Integer.parseInt(value) < 0) {
                    return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_timeout());
                }
                return FormValidation.ok();
            } catch (NumberFormatException e) {
                return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_timeout());
            }
        }

        public FormValidation doTestConnection(@QueryParameter("controllerIP") String controllerIP,
                                               @QueryParameter("controllerPort") String controllerPort,
                                               @QueryParameter("user") String user,
                                               @QueryParameter("password") Secret password) {
            int port;
            try {
                port = Integer.parseInt(controllerPort.trim());
            } catch (NumberFormatException e) {
                return FormValidation.error(Messages.NeuVectorBuilder_DescriptorImpl_errors_controllerPort());
            }
            Config config = new Config(controllerIP, port, user, Secret.toString(password).trim(), 0, false, null,
                    null, null, false, null, null,
                    null, null, null,
                    null);
            NeuVectorWorker worker = new NeuVectorWorker(null, config);
            try {
                worker.testConnection();
                return FormValidation.ok("Connection Success");
            } catch (IOException e) {
                return FormValidation.error("Connection error: " + e.getMessage());
            }
        }

        @Override
        public boolean isApplicable(Class<? extends AbstractProject> aClass) {
            return true;
        }

        @Override
        public String getDisplayName() {
            return Messages.NeuVectorBuilder_DescriptorImpl_DisplayName();
        }

        @Override
        public boolean configure(StaplerRequest req, JSONObject formData) throws FormException {
            try {
                JSONObject registriesJsonObj = formData.getJSONObject("registries");
                if (registriesJsonObj == null || registriesJsonObj.isEmpty()) {
                    registries = null;
                }
            } catch (JSONException e) {
                JSONArray registriesJsonArray = formData.getJSONArray("registries");
                if (registriesJsonArray == null || registriesJsonArray.isEmpty()) {
                    registries = null;
                }
            }
            req.bindJSON(this, formData);
            save();
            return true;
        }
    }
}