package io.jenkins.plugins.neuvector;

import hudson.AbortException;
import hudson.util.Secret;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.util.HashSet;
import java.util.Set;

import java.util.logging.Level;
import java.util.logging.Logger;
import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpDelete;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.ssl.SSLContextBuilder;
import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
import org.apache.http.entity.StringEntity;
import org.apache.http.HttpEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;


public class NeuVectorWorker {

    private static final int HTTP_CLIENT_CONFIG_TIMEOUT_SECOND = 60;
    private Log logger;
    private static final Logger LOGGER = Logger.getLogger(NeuVectorWorker.class.getName());
    private Config config;
    private String token;

    public NeuVectorWorker(Log logger, Config config) {
        this.logger = logger;
        this.config = config;
    }

    public void scan() throws IOException {
        try (CloseableHttpClient httpclient = makeHttpClient()) {
            getToken(httpclient);
            try {
                requestScan(httpclient);
            } finally {
                logout(httpclient);
            }
        }
    }

    public void testConnection() throws IOException {
        try (CloseableHttpClient httpclient = makeHttpClient()) {
            getToken(httpclient);
            logout(httpclient);
        }
    }

    private CloseableHttpClient makeHttpClient() throws AbortException {
        SSLContextBuilder builder = new SSLContextBuilder();
        SSLConnectionSocketFactory sslsf;
        try {
            builder.loadTrustMaterial(null, new TrustSelfSignedStrategy());
            sslsf = new SSLConnectionSocketFactory(builder.build(), new TrustAllStrategy());
        } catch (NoSuchAlgorithmException | KeyStoreException | KeyManagementException e) {
            throw new AbortException("SSL context builder error.");
        }
        RequestConfig config = RequestConfig.custom().setConnectTimeout(HTTP_CLIENT_CONFIG_TIMEOUT_SECOND * 1000).build();
        return HttpClients.custom().setSSLSocketFactory(sslsf).setDefaultRequestConfig(config).build();
    }

    private void getToken(CloseableHttpClient httpclient) throws AbortException {
        String uriPathForGetToken = "/v1/auth";
        URI uriForGetToken = buildUri(config.getControllerIP(), config.getControllerPort(), uriPathForGetToken);

        HttpPost httpPostForGetToken = new HttpPost(uriForGetToken);
        httpPostForGetToken.addHeader("Content-Type", "application/json");

        JSONObject passwordJson = new JSONObject();
        passwordJson.put("username", config.getUser());
        passwordJson.put("password", config.getPassword());
        JSONObject httpBodyJson = new JSONObject();
        httpBodyJson.put("password", passwordJson);

        try {
            httpPostForGetToken.setEntity(new StringEntity(httpBodyJson.toString()));
        } catch (UnsupportedEncodingException e) {
            if (logger != null) {
                logger.log("Unsupported encoding from NeuVector Username and/or Password in global configuration.");
            }
            throw new AbortException("Unsupported encoding from NeuVector Username and/or Password in global configuration.");
        }

        try (CloseableHttpResponse httpResponseFromGetToken = httpclient.execute(httpPostForGetToken)) {
            int statusCode = httpResponseFromGetToken.getStatusLine().getStatusCode();
            HttpEntity httpEntityFromGetToken = httpResponseFromGetToken.getEntity();
            String serverMessageFromGetToken = EntityUtils.toString(httpEntityFromGetToken);
            EntityUtils.consume(httpEntityFromGetToken);

            if (statusCode == 200) {
                token = JSONObject.fromObject(serverMessageFromGetToken).getJSONObject("token").getString("token");
            } else if (statusCode == 401 || statusCode == 404 || statusCode == 405) {
                if (logger != null) {
                    logger.log("Invalid credential of NeuVector controller");
                }
                throw new AbortException("Invalid credential of NeuVector controller");
            } else {
                if (logger != null) {
                    logger.log("Failed to get token. Http status code: " + statusCode + ". Message: " + serverMessageFromGetToken);
                }
                throw new AbortException("Failed to get token. Http status code: " + statusCode + ". Message: " + serverMessageFromGetToken);
            }
        } catch (ClientProtocolException e) {
            if (logger != null) {
                logger.log("Invalid NeuVector controller IP or port.");
            }
            throw new AbortException("Invalid NeuVector controller IP or port.");
        } catch (AbortException e) {
            throw new AbortException();
        } catch (IOException e) {
            if (logger != null) {
                logger.log("NeuVector controller connection error.");
            }
            throw new AbortException("NeuVector controller connection error.");
        }
    }

    private void requestScan(CloseableHttpClient httpclient) throws IOException {
        long startTimeMillis = System.currentTimeMillis();
        int timeoutSeconds = config.getTimeout() * 60;

        String uriPathForScan = "/v1/scan/repository";
        URI uriForScan = buildUri(config.getControllerIP(), config.getControllerPort(), uriPathForScan);

        HttpPost httpPostForScan = new HttpPost(uriForScan);
        httpPostForScan.addHeader("Content-Type", "application/json");
        httpPostForScan.addHeader("X-Auth-Token", token);

        JSONObject httpBodyJson = new JSONObject();
        JSONObject requestJson = new JSONObject();
        requestJson.put("repository", config.getRepository());
        if (config.getTag() != null) {
            requestJson.put("tag", config.getTag());
        }

        if (config.getScanMeta() != null) {
            JSONObject metaJson = new JSONObject();
            metaJson.put("source", config.getScanMeta().getSource());
            metaJson.put("user", config.getScanMeta().getUser());
            metaJson.put("job", config.getScanMeta().getJob());
            metaJson.put("workspace", config.getScanMeta().getWorkspace());
            requestJson.put("metadata", metaJson);
        } else {
            requestJson.put("metadata",null);
        }

        if (config.isLocal()) {
            requestJson.put("registry", "");
            requestJson.put("username", "");
            requestJson.put("password", "");
        } else {
            requestJson.put("registry", config.getRegistry().getRegUrl());
            requestJson.put("username", config.getRegistry().getRegUsername());
            requestJson.put("password", Secret.toString(config.getRegistry().getRegPassword()).trim());
        }
        requestJson.put("scan_layers", config.getScanLayers());

        httpBodyJson.put("request", requestJson);

        try{
            httpPostForScan.setEntity(new StringEntity(httpBodyJson.toString()));
        } catch (UnsupportedEncodingException e) {
            logger.log("Unsupported encoding from registry, repository or tag.");
            throw new AbortException();
        }

        CloseableHttpResponse httpResponseFromScan = null;
        try {
            httpResponseFromScan = httpclient.execute(httpPostForScan);
            while (httpResponseFromScan.getStatusLine().getStatusCode() == 304) {
                if (timeoutSeconds > 0) {
                    long elapsedSeconds = (System.currentTimeMillis() - startTimeMillis) / 1000;
                    if (elapsedSeconds > timeoutSeconds) {
                        logger.log("Time out.");
                        throw new AbortException();
                    }
                }

                httpResponseFromScan = httpclient.execute(httpPostForScan);
                logger.log("Scanning in progress...");
            }

            int statusCode = httpResponseFromScan.getStatusLine().getStatusCode();
            HttpEntity httpEntityFromScan = httpResponseFromScan.getEntity();
            String serverMessageFromScan = "N/A";

            if (httpEntityFromScan != null) {
                serverMessageFromScan = EntityUtils.toString(httpEntityFromScan);
                EntityUtils.consume(httpEntityFromScan);
            }

            if (statusCode == 200 && httpEntityFromScan != null) {
                processScanReport(serverMessageFromScan);
            } else {
                logger.log("Scan failed. Http status code: " + statusCode + ". Message: " + serverMessageFromScan);
                throw new AbortException("Scan failed.");
            }
        } catch (AbortException e) {
            throw e;
        } catch (IOException e) {
            LOGGER.log(Level.WARNING, "NeuVector controller connection error", e);
            throw new AbortException("NeuVector controller connection error. " + e.getMessage());
        } finally {
            if (httpResponseFromScan != null) {
                httpResponseFromScan.close();
            }
        }
    }

    private void logout(CloseableHttpClient httpclient) throws IOException {
        String uriPathForLogout = "/v1/auth";
        URI uriForLogout = buildUri(config.getControllerIP(), config.getControllerPort(), uriPathForLogout);
        HttpDelete httpDeleteForLogout = new HttpDelete(uriForLogout);
        httpDeleteForLogout.addHeader("Content-Type", "application/json");
        httpDeleteForLogout.addHeader("X-Auth-Token", token);
        CloseableHttpResponse httpResponseFromLogout = httpclient.execute(httpDeleteForLogout);
        httpResponseFromLogout.close();
    }

    private URI buildUri(String host, int port, String path) throws AbortException {
        URI uri;
        try {
            uri = new URIBuilder().setScheme("https").setHost(host).setPort(port).setPath(path).build();
        } catch (URISyntaxException e) {
            logger.log("URI syntax error from NeuVector Controller IP and/or API port in global configuration.");
            throw new AbortException();
        }
        return uri;
    }

    private void processScanReport(String serverMessageFromScan) throws AbortException {
        int currentHighSeverity = 0;
        int currentMediumSeverity = 0;
        boolean foundName = false;
        Set<String> namesToPresent = new HashSet<>();
        Set<String> nameSetOfVulnerability = new HashSet<>();

        if (config.getNameOfVulnerabilityToFailOne() != null && !config.getNameOfVulnerabilityToFailOne().isEmpty()) {
            nameSetOfVulnerability.add(config.getNameOfVulnerabilityToFailOne().toLowerCase());
        }
        if (config.getNameOfVulnerabilityToFailTwo() != null && !config.getNameOfVulnerabilityToFailTwo().isEmpty()) {
            nameSetOfVulnerability.add(config.getNameOfVulnerabilityToFailTwo().toLowerCase());
        }
        if (config.getNameOfVulnerabilityToFailThree() != null && !config.getNameOfVulnerabilityToFailThree().isEmpty()) {
            nameSetOfVulnerability.add(config.getNameOfVulnerabilityToFailThree().toLowerCase());
        }
        if (config.getNameOfVulnerabilityToFailFour() != null && !config.getNameOfVulnerabilityToFailFour().isEmpty()) {
            nameSetOfVulnerability.add(config.getNameOfVulnerabilityToFailFour().toLowerCase());
        }

        logger.log();
        logger.log("************************ Scan Report ************************");

        JSONObject reportJson = JSONObject.fromObject(serverMessageFromScan).getJSONObject("report");

        if (!config.isLocal()) {
            logger.log("Registry URL: " + reportJson.getString("registry"));
        }
        logger.log("Repository: " + reportJson.getString("repository"));
        logger.log("Tag: " + reportJson.getString("tag"));
        logger.log();
        logger.log("********************** Vulnerabilities **********************");
        logger.log();

        JSONArray vulnerabilityArray = reportJson.getJSONArray("vulnerabilities");

        if (vulnerabilityArray.size() == 0) {
            logger.log("Scanned. No vulnerabilities found.");
        } else {
            for (int i = 0; i < vulnerabilityArray.size(); i++) {
                JSONObject vulnerabilityObject = vulnerabilityArray.getJSONObject(i);

                int vulnerabilityNumber = i + 1;
                String name = vulnerabilityObject.getString("name").toLowerCase();
                String severity = vulnerabilityObject.getString("severity");

                logger.log("********************** Vulnerability " + vulnerabilityNumber + " **********************");
                logger.log("Name: " + name.toUpperCase());
                logger.log("Score: " + vulnerabilityObject.get("score"));
                logger.log("Severity: " + severity);
                logger.log("Vectors: " + vulnerabilityObject.getString("vectors"));
                logger.log("Description: " + vulnerabilityObject.getString("description"));
                logger.log("Package_name: " + vulnerabilityObject.getString("package_name"));
                logger.log("Package_version: " + vulnerabilityObject.getString("package_version"));
                logger.log("Fixed_version: " + vulnerabilityObject.getString("fixed_version"));
                logger.log("Link: " + vulnerabilityObject.getString("link"));
                logger.log();

                if (!nameSetOfVulnerability.isEmpty() && nameSetOfVulnerability.contains(name)) {
                    foundName = true;
                    namesToPresent.add(name.toUpperCase());
                }

                if (severity.equalsIgnoreCase("High")) {
                    currentHighSeverity++;
                } else if (severity.equalsIgnoreCase("Medium")) {
                    currentMediumSeverity++;
                }
            }
        }

        if (config.getScanLayers()) {
            logger.log();
            if (reportJson.has("layers")) {
                logger.log("**************** Layer Vulnerability History ****************");
                logger.log();
                JSONArray layerArray = reportJson.getJSONArray("layers");
                for (int i = 0; i < layerArray.size(); i++) {
                    JSONObject layerObject = layerArray.getJSONObject(i);
                    String layerDigest = layerObject.getString("digest").substring(0, 12);
                    JSONArray layerVulnerabilityArray = layerObject.getJSONArray("vulnerabilities");
                    logger.log("Layer digest " + layerDigest + " contains " + layerVulnerabilityArray.size() + " vulnerabilities.");
                    logger.log();
                    for (int j = 0; j < layerVulnerabilityArray.size(); j++) {
                        JSONObject layerVulnerabilityObject = layerVulnerabilityArray.getJSONObject(j);
                        logger.log("Name: " + layerVulnerabilityObject.getString("name")
                            + ", Score: " + layerVulnerabilityObject.get("score")
                            + ", Package_name: " + layerVulnerabilityObject.getString("package_name")
                            + ", Package_version: " + layerVulnerabilityObject.getString("package_version")
                            + ", Fixed_version: " + layerVulnerabilityObject.getString("fixed_version")
                            + ", Link: " + layerVulnerabilityObject.getString("link"));
                    }
                    logger.log();
                }
            } else {
                logger.log("*** Your Controller Does Not Support Layer Vulnerability Scan ***");
            }
        }
        makeIfFailDecision(currentHighSeverity, currentMediumSeverity, foundName, namesToPresent);
    }

    private void makeIfFailDecision(int currentHighSeverity, int currentMediumSeverity, boolean foundName,
                                    Set<String> namesToPresent) throws AbortException {
        boolean numberExceed = false;
        StringBuilder statementBuilder = new StringBuilder();

        if (config.getNumberOfHighSeverityToFail() != null && !config.getNumberOfHighSeverityToFail().isEmpty()) {
            int configNumberOfHigh = Integer.parseInt(config.getNumberOfHighSeverityToFail());
            if (configNumberOfHigh != 0 && configNumberOfHigh <= currentHighSeverity) {
                numberExceed = true;
                statementBuilder.append(currentHighSeverity).append(" High severity vulnerabilities");
            }
        }

        if (config.getNumberOfMediumSeverityToFail() != null && !config.getNumberOfMediumSeverityToFail().isEmpty()) {
            int configNumberOfMedium = Integer.parseInt(config.getNumberOfMediumSeverityToFail());
            if (configNumberOfMedium != 0 && configNumberOfMedium <= currentMediumSeverity) {
                if (numberExceed) {
                    statementBuilder.append(", ");
                }
                numberExceed = true;
                statementBuilder.append(currentMediumSeverity).append(" Medium severity vulnerabilities");
            }
        }

        if (foundName) {
            if (numberExceed) {
                statementBuilder.append(", and ");
            }
            statementBuilder.append("vulnerabilities: ").append(namesToPresent.toString());
        }

        if (numberExceed || foundName) {
            statementBuilder.append(" are present.");
            logger.log("Build failed because " + statementBuilder.toString());
            throw new AbortException();
        }
    }
}
