package io.jenkins.plugins.neuvector;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import hudson.AbortException;
import hudson.Launcher;
import hudson.model.Run;
import hudson.util.ArgumentListBuilder;
import hudson.util.Secret;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.io.UnsupportedEncodingException;
import java.net.URI;
import java.net.URISyntaxException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.security.KeyManagementException;
import java.security.KeyStoreException;
import java.security.NoSuchAlgorithmException;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Stream;

import net.sf.json.JSONArray;
import net.sf.json.JSONObject;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpDelete;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.conn.ssl.SSLConnectionSocketFactory;
import org.apache.http.ssl.SSLContextBuilder;
import org.apache.http.conn.ssl.TrustSelfSignedStrategy;
import org.apache.http.entity.StringEntity;
import org.apache.http.HttpEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;


public class NeuVectorWorker {

    private static final int HTTP_CLIENT_CONFIG_TIMEOUT_SECOND = 60;
    private Log logger;
    private Config config;
    private String token;
    private static final String SCAN_REPORT= "/var/neuvector/scan_result.json";

    public NeuVectorWorker(Log logger, Config config) {
        this.logger = logger;
        this.config = config;
    }

    @SuppressFBWarnings("DMI_HARDCODED_ABSOLUTE_FILENAME")
    public void scan(Run<?, ?> run, Launcher launcher, Log console) throws IOException, InterruptedException {
        String scanJson = "";

        if (config.isStandaloneScanner()){
            int exitCode = 0;
            ArgumentListBuilder args = new ArgumentListBuilder();

            File outFile = new File(run.getRootDir(), "out");
            Launcher.ProcStarter ps = launcher.launch();
            try (PrintStream print_stream = new PrintStream(outFile, "UTF-8")){
                ps.stderr(print_stream);
                ps.stdout(print_stream);
                ps.quiet(true);

                if(! config.getScannerRegistryUser().isEmpty()){
                    args.add("docker", "login");
                    args.add("-u",config.getScannerRegistryUser(),"-p");
                    args.addMasked(config.getScannerRegistryPassword());
                    args.add(config.getScannerRegistryURL());
                    ps.cmds(args);
                    console.log("Logging in " + config.getScannerRegistryURL() + " with " + config.getScannerRegistryUser() + " ... ");
                    exitCode = ps.join();
                }

                if(exitCode != 0) {
                    console.log("docker failed to login " + config.getScannerRegistryURL() + " Please check the global configuration.");
                    exitCode = 0;
                }

                args.clear();
                args.add("docker", "pull");
                args.add(config.getScannerRegistryURL() + "/" + config.getScannerImage());
                ps.cmds(args);
                console.log("Pulling NeuVector Scanner from " + config.getScannerRegistryURL() + "/" + config.getScannerImage() + " ...");
                exitCode = ps.join(); // RUN !

                if(exitCode != 0) {
                    console.log("docker failed to pull " + config.getScannerRegistryURL() + "/" + config.getScannerImage() + " Please check the global configuration.");
                    exitCode = 0;
                }

                args.clear();
                args.add("docker", "run");
                args.add("--name", "neuvector.scanner", "--rm");

                String regUrl = "";
                if(!config.isLocal()){
                    regUrl = config.getRegistry().getRegUrl();
                    args.add("-e","SCANNER_REGISTRY=" + regUrl, "-e", "SCANNER_REGISTRY_USERNAME=" + config.getRegistry().getRegUsername() ,"-e", "SCANNER_REGISTRY_PASSWORD=" + config.getRegistry().getRegPassword());
                    regUrl = regUrl + "/";
                }
                args.add("-e", "SCANNER_REPOSITORY="+config.getRepository(), "-e", "SCANNER_TAG="+config.getTag(), "-e", "SCANNER_SCAN_LAYERS="+config.getScanLayers(), "-e", "SCANNER_LICENSE="+config.getLicense(), "-v", "/var/run/docker.sock:/var/run/docker.sock", "-v","/var/neuvector:/var/neuvector",config.getScannerImage());

                ps.cmds(args);

                console.log("Scanning " + regUrl + config.getRepository() + ":" + config.getTag());
                exitCode = ps.join(); // RUN !

                if( exitCode != 0 ){
                    console.log("Scan error. Check log in " + outFile.getAbsolutePath());
                    throw new AbortException("Scan error.");
                }
            }

            StringBuilder contentBuilder = new StringBuilder();
            try (Stream<String> stream = Files.lines(Paths.get(SCAN_REPORT), StandardCharsets.UTF_8)) {
                stream.forEach(s -> contentBuilder.append(s).append("\n"));
            } catch (IOException e) {
                e.printStackTrace();
            }
            scanJson = contentBuilder.toString();
        }else{
            try (CloseableHttpClient httpclient = makeHttpClient()) {
                getToken(httpclient);
                try{
                    scanJson = requestScan(httpclient);
                }finally {
                    logout(httpclient);
                }

            }
        }
        processScanReport(scanJson);
    }

    public void testConnection() throws IOException {
        try (CloseableHttpClient httpclient = makeHttpClient()) {
            getToken(httpclient);
            logout(httpclient);
        }
    }

    private CloseableHttpClient makeHttpClient() throws AbortException {
        SSLContextBuilder builder = new SSLContextBuilder();
        SSLConnectionSocketFactory sslsf;
        try {
            builder.loadTrustMaterial(null, new TrustSelfSignedStrategy());
            sslsf = new SSLConnectionSocketFactory(builder.build(), new TrustAllStrategy());
        } catch (NoSuchAlgorithmException | KeyStoreException | KeyManagementException e) {
            throw new AbortException("SSL context builder error.");
        }
        RequestConfig config = RequestConfig.custom().setConnectTimeout(HTTP_CLIENT_CONFIG_TIMEOUT_SECOND * 1000).build();
        return HttpClients.custom().setSSLSocketFactory(sslsf).setDefaultRequestConfig(config).build();
    }

    private void getToken(CloseableHttpClient httpclient) throws AbortException {
        String uriPathForGetToken = "/v1/auth";
        URI uriForGetToken = buildUri(config.getControllerIP(), config.getControllerPort(), uriPathForGetToken);

        HttpPost httpPostForGetToken = new HttpPost(uriForGetToken);
        httpPostForGetToken.addHeader("Content-Type", "application/json");

        JSONObject passwordJson = new JSONObject();
        passwordJson.put("username", config.getUser());
        passwordJson.put("password", config.getPassword());
        JSONObject httpBodyJson = new JSONObject();
        httpBodyJson.put("password", passwordJson);

        try {
            httpPostForGetToken.setEntity(new StringEntity(httpBodyJson.toString()));
        } catch (UnsupportedEncodingException e) {
            if (logger != null) {
                logger.log("Unsupported encoding from NeuVector Username and/or Password in global configuration.");
            }
            throw new AbortException("Unsupported encoding from NeuVector Username and/or Password in global configuration.");
        }

        try (CloseableHttpResponse httpResponseFromGetToken = httpclient.execute(httpPostForGetToken)) {
            int statusCode = httpResponseFromGetToken.getStatusLine().getStatusCode();
            HttpEntity httpEntityFromGetToken = httpResponseFromGetToken.getEntity();
            String serverMessageFromGetToken = EntityUtils.toString(httpEntityFromGetToken);
            EntityUtils.consume(httpEntityFromGetToken);

            if (statusCode == 200) {
                token = JSONObject.fromObject(serverMessageFromGetToken).getJSONObject("token").getString("token");
            } else if (statusCode == 401 || statusCode == 404 || statusCode == 405) {
                if (logger != null) {
                    logger.log("Invalid credential of NeuVector controller");
                }
                throw new AbortException("Invalid credential of NeuVector controller");
            } else {
                if (logger != null) {
                    logger.log("Failed to get token. Http status code: " + statusCode + ". Message: " + serverMessageFromGetToken);
                }
                throw new AbortException("Failed to get token. Http status code: " + statusCode + ". Message: " + serverMessageFromGetToken);
            }
        } catch (ClientProtocolException e) {
            if (logger != null) {
                logger.log("Invalid NeuVector controller IP or port.");
            }
            throw new AbortException("Invalid NeuVector controller IP or port.");
        } catch (AbortException e) {
            throw new AbortException();
        } catch (IOException e) {
            if (logger != null) {
                logger.log("NeuVector controller connection error.");
            }
            throw new AbortException("NeuVector controller connection error.");
        }
    }

    private String requestScan(CloseableHttpClient httpclient) throws IOException {
        long startTimeMillis = System.currentTimeMillis();
        int timeoutSeconds = config.getTimeout() * 60;

        String uriPathForScan = "/v1/scan/repository";
        URI uriForScan = buildUri(config.getControllerIP(), config.getControllerPort(), uriPathForScan);

        HttpPost httpPostForScan = new HttpPost(uriForScan);
        httpPostForScan.addHeader("Content-Type", "application/json");
        httpPostForScan.addHeader("X-Auth-Token", token);

        JSONObject httpBodyJson = new JSONObject();
        JSONObject requestJson = new JSONObject();
        requestJson.put("repository", config.getRepository());
        if (config.getTag() != null) {
            requestJson.put("tag", config.getTag());
        }

        if (config.getScanMeta() != null) {
            JSONObject metaJson = new JSONObject();
            metaJson.put("source", config.getScanMeta().getSource());
            metaJson.put("user", config.getScanMeta().getUser());
            metaJson.put("job", config.getScanMeta().getJob());
            metaJson.put("workspace", config.getScanMeta().getWorkspace());
            requestJson.put("metadata", metaJson);
        } else {
            requestJson.put("metadata",null);
        }

        if (config.isLocal()) {
            requestJson.put("registry", "");
            requestJson.put("username", "");
            requestJson.put("password", "");
        } else {
            requestJson.put("registry", config.getRegistry().getRegUrl());
            requestJson.put("username", config.getRegistry().getRegUsername());
            requestJson.put("password", Secret.toString(config.getRegistry().getRegPassword()).trim());
        }
        requestJson.put("scan_layers", config.getScanLayers());

        httpBodyJson.put("request", requestJson);

        try{
            httpPostForScan.setEntity(new StringEntity(httpBodyJson.toString()));
        } catch (UnsupportedEncodingException e) {
            logger.log("Unsupported encoding from registry, repository or tag.");
            throw new AbortException();
        }

        CloseableHttpResponse httpResponseFromScan = null;
        try {
            httpResponseFromScan = httpclient.execute(httpPostForScan);
            while (httpResponseFromScan.getStatusLine().getStatusCode() == 304) {
                if (timeoutSeconds > 0) {
                    long elapsedSeconds = (System.currentTimeMillis() - startTimeMillis) / 1000;
                    if (elapsedSeconds > timeoutSeconds) {
                        logger.log("Time out.");
                        throw new AbortException();
                    }
                }

                httpResponseFromScan = httpclient.execute(httpPostForScan);
                logger.log("Scanning in progress...");
            }

            int statusCode = httpResponseFromScan.getStatusLine().getStatusCode();
            HttpEntity httpEntityFromScan = httpResponseFromScan.getEntity();
            String serverMessageFromScan = "N/A";

            if (httpEntityFromScan != null) {
                serverMessageFromScan = EntityUtils.toString(httpEntityFromScan);
                EntityUtils.consume(httpEntityFromScan);
            }

            if (statusCode != 200 || httpEntityFromScan == null) {
                logger.log("Scan failed. Http status code: " + statusCode + ". Message: " + serverMessageFromScan);
                throw new AbortException("Scan failed.");
            }
            return serverMessageFromScan;
        } catch (AbortException e) {
            throw new AbortException();
        } catch (IOException e) {
            logger.log("NeuVector controller connection error.");
            throw new AbortException();
        } finally {
            if (httpResponseFromScan != null) {
                httpResponseFromScan.close();
            }
        }
    }

    private void logout(CloseableHttpClient httpclient) throws IOException {
        String uriPathForLogout = "/v1/auth";
        URI uriForLogout = buildUri(config.getControllerIP(), config.getControllerPort(), uriPathForLogout);
        HttpDelete httpDeleteForLogout = new HttpDelete(uriForLogout);
        httpDeleteForLogout.addHeader("Content-Type", "application/json");
        httpDeleteForLogout.addHeader("X-Auth-Token", token);
        CloseableHttpResponse httpResponseFromLogout = httpclient.execute(httpDeleteForLogout);
        httpResponseFromLogout.close();
    }

    private URI buildUri(String host, int port, String path) throws AbortException {
        URI uri;
        try {
            uri = new URIBuilder().setScheme("https").setHost(host).setPort(port).setPath(path).build();
        } catch (URISyntaxException e) {
            logger.log("URI syntax error from NeuVector Controller IP and/or API port in global configuration.");
            throw new AbortException();
        }
        return uri;
    }

    private void processScanReport(String serverMessageFromScan) throws AbortException {
        int currentHighSeverity = 0;
        int currentMediumSeverity = 0;
        boolean foundName = false;
        Set<String> namesToPresent = new HashSet<>();
        Set<String> nameSetOfVulnerability = new HashSet<>();
        Set<String> exemptVulnerabilitySet = new HashSet<>();

        if (config.getNameOfVulnerabilityToFailOne() != null && !config.getNameOfVulnerabilityToFailOne().isEmpty()) {
            nameSetOfVulnerability.add(config.getNameOfVulnerabilityToFailOne().toLowerCase());
        }
        if (config.getNameOfVulnerabilityToFailTwo() != null && !config.getNameOfVulnerabilityToFailTwo().isEmpty()) {
            nameSetOfVulnerability.add(config.getNameOfVulnerabilityToFailTwo().toLowerCase());
        }
        if (config.getNameOfVulnerabilityToFailThree() != null && !config.getNameOfVulnerabilityToFailThree().isEmpty()) {
            nameSetOfVulnerability.add(config.getNameOfVulnerabilityToFailThree().toLowerCase());
        }
        if (config.getNameOfVulnerabilityToFailFour() != null && !config.getNameOfVulnerabilityToFailFour().isEmpty()) {
            nameSetOfVulnerability.add(config.getNameOfVulnerabilityToFailFour().toLowerCase());
        }

        if (config.getNameOfVulnerabilityToExemptOne() != null && !config.getNameOfVulnerabilityToExemptOne().isEmpty()) {
            exemptVulnerabilitySet.add(config.getNameOfVulnerabilityToExemptOne().toLowerCase());
        }
        if (config.getNameOfVulnerabilityToExemptTwo() != null && !config.getNameOfVulnerabilityToExemptTwo().isEmpty()) {
            exemptVulnerabilitySet.add(config.getNameOfVulnerabilityToExemptTwo().toLowerCase());
        }
        if (config.getNameOfVulnerabilityToExemptThree() != null && !config.getNameOfVulnerabilityToExemptThree().isEmpty()) {
            exemptVulnerabilitySet.add(config.getNameOfVulnerabilityToExemptThree().toLowerCase());
        }
        if (config.getNameOfVulnerabilityToExemptFour() != null && !config.getNameOfVulnerabilityToExemptFour().isEmpty()) {
            exemptVulnerabilitySet.add(config.getNameOfVulnerabilityToExemptFour().toLowerCase());
        }

        logger.log();
        logger.log();
        logger.log("************************ Scan Report ************************");

        JSONObject reportJson = JSONObject.fromObject(serverMessageFromScan).getJSONObject("report");

        if ( reportJson.isNullObject() ){
            logger.log("Scan failed. Error Message: " + JSONObject.fromObject(serverMessageFromScan).get("error_message").toString());
            throw new AbortException();
        }

        if (!config.isLocal()) {
            logger.log("Registry URL: " + reportJson.getString("registry"));
        }
        logger.log("Repository: " + reportJson.getString("repository"));
        logger.log("Tag: " + reportJson.getString("tag"));
        logger.log();
        logger.log("********************** Vulnerabilities **********************");
        logger.log();

        JSONArray vulnerabilityArray = reportJson.getJSONArray("vulnerabilities");

        if (vulnerabilityArray.size() == 0) {
            logger.log("Scanned. No vulnerabilities found.");
        } else {
            int vulnerabilityNumber = 0;
            for (int i = 0; i < vulnerabilityArray.size(); i++) {
                JSONObject vulnerabilityObject = vulnerabilityArray.getJSONObject(i);
                String name = vulnerabilityObject.getString("name").toLowerCase();

                if (!nameSetOfVulnerability.isEmpty() && nameSetOfVulnerability.contains(name)) {
                    foundName = true;
                    namesToPresent.add(name.toUpperCase());
                }

                if ( exemptVulnerabilitySet.isEmpty() || !exemptVulnerabilitySet.contains(name) ) {
                    vulnerabilityNumber = vulnerabilityNumber + 1;
                    String severity = vulnerabilityObject.getString("severity");
                    logger.log("********************** Vulnerability " + vulnerabilityNumber + " **********************");
                    logger.log("Name: " + name.toUpperCase());
                    logger.log("Score: " + vulnerabilityObject.get("score"));
                    logger.log("Severity: " + severity);
                    logger.log("Vectors: " + vulnerabilityObject.getString("vectors"));
                    logger.log("Description: " + vulnerabilityObject.getString("description"));
                    logger.log("Package_name: " + vulnerabilityObject.getString("package_name"));
                    logger.log("Package_version: " + vulnerabilityObject.getString("package_version"));
                    logger.log("Fixed_version: " + vulnerabilityObject.getString("fixed_version"));
                    logger.log("Link: " + vulnerabilityObject.getString("link"));
                    logger.log();
                    if (severity.equalsIgnoreCase("High")) {
                        currentHighSeverity++;
                    } else if (severity.equalsIgnoreCase("Medium")) {
                        currentMediumSeverity++;
                    }
                }else{
                    logger.log("********************** Exempt Vulnerability **********************");
                    logger.log("The vulnerability " + name.toUpperCase() + " is exempt.");
                    logger.log();
                }
            }
        }

        if (config.getScanLayers()) {
            logger.log();
            if (reportJson.has("layers")) {
                logger.log("**************** Layer Vulnerability History ****************");
                logger.log();
                JSONArray layerArray = reportJson.getJSONArray("layers");
                for (int i = 0; i < layerArray.size(); i++) {
                    JSONObject layerObject = layerArray.getJSONObject(i);
                    String layerDigest = layerObject.getString("digest").substring(0, 12);
                    JSONArray layerVulnerabilityArray = layerObject.getJSONArray("vulnerabilities");
                    int layerVulnerabilitySize = 0;
                    for (int j = 0; j < layerVulnerabilityArray.size(); j++) {
                        JSONObject layerVulnerabilityObject = layerVulnerabilityArray.getJSONObject(j);
                        String vulnerabilityName = layerVulnerabilityObject.getString("name").toLowerCase();
                        if ( exemptVulnerabilitySet.isEmpty() || !exemptVulnerabilitySet.contains(vulnerabilityName) ) {
                            layerVulnerabilitySize = layerVulnerabilitySize + 1;
                        }
                    }
                    logger.log("Layer digest " + layerDigest + " contains " + layerVulnerabilitySize + " vulnerabilities.");
                    logger.log();
                    for (int j = 0; j < layerVulnerabilityArray.size(); j++) {
                        JSONObject layerVulnerabilityObject = layerVulnerabilityArray.getJSONObject(j);
                        String vulnerabilityName = layerVulnerabilityObject.getString("name").toLowerCase();
                        if ( exemptVulnerabilitySet.isEmpty() || !exemptVulnerabilitySet.contains(vulnerabilityName) ) {
                            logger.log("Name: " + vulnerabilityName
                                    + ", Score: " + layerVulnerabilityObject.get("score")
                                    + ", Package_name: " + layerVulnerabilityObject.getString("package_name")
                                    + ", Package_version: " + layerVulnerabilityObject.getString("package_version")
                                    + ", Fixed_version: " + layerVulnerabilityObject.getString("fixed_version")
                                    + ", Link: " + layerVulnerabilityObject.getString("link"));
                        }else {
                            logger.log("The vulnerability " + vulnerabilityName + " is exempt. ");
                        }
                    }
                    logger.log();
                }
            } else {
                logger.log("*** Your Controller Does Not Support Layer Vulnerability Scan ***");
            }
        }
        makeIfFailDecision(currentHighSeverity, currentMediumSeverity, foundName, namesToPresent);
    }

    private void makeIfFailDecision(int currentHighSeverity, int currentMediumSeverity, boolean foundName,
                                    Set<String> namesToPresent) throws AbortException {
        boolean numberExceed = false;
        StringBuilder statementBuilder = new StringBuilder();

        if (config.getNumberOfHighSeverityToFail() != null && !config.getNumberOfHighSeverityToFail().isEmpty()) {
            int configNumberOfHigh = Integer.parseInt(config.getNumberOfHighSeverityToFail());
            if (configNumberOfHigh != 0 && configNumberOfHigh <= currentHighSeverity) {
                numberExceed = true;
                statementBuilder.append(currentHighSeverity).append(" High severity vulnerabilities");
            }
        }

        if (config.getNumberOfMediumSeverityToFail() != null && !config.getNumberOfMediumSeverityToFail().isEmpty()) {
            int configNumberOfMedium = Integer.parseInt(config.getNumberOfMediumSeverityToFail());
            if (configNumberOfMedium != 0 && configNumberOfMedium <= currentMediumSeverity) {
                if (numberExceed) {
                    statementBuilder.append(", ");
                }
                numberExceed = true;
                statementBuilder.append(currentMediumSeverity).append(" Medium severity vulnerabilities");
            }
        }

        if (foundName) {
            if (numberExceed) {
                statementBuilder.append(", and ");
            }
            statementBuilder.append("vulnerabilities: ").append(namesToPresent.toString());
        }

        if (numberExceed || foundName) {
            statementBuilder.append(" are present.");
            logger.log("Build failed because " + statementBuilder.toString());
            throw new AbortException();
        }
    }
}
